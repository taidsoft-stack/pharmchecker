schema_name,function_name,arguments,language,security_definer,volatility,function_definition
auth,email,,sql,false,s,"CREATE OR REPLACE FUNCTION auth.email()
 RETURNS text
 LANGUAGE sql
 STABLE
AS $function$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.email', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')
  )::text
$function$
"
auth,jwt,,sql,false,s,"CREATE OR REPLACE FUNCTION auth.jwt()
 RETURNS jsonb
 LANGUAGE sql
 STABLE
AS $function$
  select 
    coalesce(
        nullif(current_setting('request.jwt.claim', true), ''),
        nullif(current_setting('request.jwt.claims', true), '')
    )::jsonb
$function$
"
auth,role,,sql,false,s,"CREATE OR REPLACE FUNCTION auth.role()
 RETURNS text
 LANGUAGE sql
 STABLE
AS $function$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.role', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')
  )::text
$function$
"
auth,uid,,sql,false,s,"CREATE OR REPLACE FUNCTION auth.uid()
 RETURNS uuid
 LANGUAGE sql
 STABLE
AS $function$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.sub', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')
  )::uuid
$function$
"
public,force_user_deletion,"_user_id uuid, _reason text, _ip_address inet, _user_agent text",plpgsql,true,v,"CREATE OR REPLACE FUNCTION public.force_user_deletion(_user_id uuid, _reason text DEFAULT NULL::text, _ip_address inet DEFAULT NULL::inet, _user_agent text DEFAULT NULL::text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_admin_id uuid := auth.uid();
begin
  -- 관리자 권한 체크
  if not exists (
    select 1
    from admins
    where admin_id = v_admin_id
      and is_active = true
  ) then
    raise exception 'Not authorized';
  end if;

  -- 이미 탈퇴한 경우 방지
  if exists (
    select 1
    from users
    where user_id = _user_id
      and is_deleted = true
  ) then
    raise exception 'User already deleted';
  end if;

  -- users 업데이트
  update users
     set is_deleted     = true,
         deleted_at     = now(),
         deleted_reason = _reason,
         deleted_by     = v_admin_id
   where user_id = _user_id;

  -- 탈퇴 로그 기록
  insert into user_deletion_logs (
    user_id,
    deleted_by,
    reason,
    ip_address,
    user_agent
  ) values (
    _user_id,
    v_admin_id,
    _reason,
    _ip_address,
    _user_agent
  );
end;
$function$
"
public,get_miss_mached_drug,_pack_barcode text,plpgsql,true,v,"CREATE OR REPLACE FUNCTION public.get_miss_mached_drug(_pack_barcode text)
 RETURNS TABLE(drug_name text, location text, source text)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_tenant_id uuid := auth.uid();
BEGIN
  /* 1️⃣ drugs 테이블에서 먼저 조회 */
  RETURN QUERY
  SELECT
    d.drug_name,
    d.location,
    'drugs'::text AS source
  FROM public.drugs d
  WHERE d.tenant_id = v_tenant_id
    AND d.pack_barcode = _pack_barcode;

  IF FOUND THEN
    RETURN;
  END IF;

  /* 2️⃣ drug_library 에서 조회 (location 없음) */
  RETURN QUERY
  SELECT
    dl.drug_name,
    NULL::text AS location,
    'drug_library'::text AS source
  FROM public.drug_library dl
  WHERE dl.pack_barcode = _pack_barcode;

END;
$function$
"
public,get_rxheads,"_patient_number text, _selected_date text, _patient_name text, _limit integer, _offset integer",plpgsql,true,v,"CREATE OR REPLACE FUNCTION public.get_rxheads(_patient_number text DEFAULT NULL::text, _selected_date text DEFAULT NULL::text, _patient_name text DEFAULT NULL::text, _limit integer DEFAULT 50, _offset integer DEFAULT 0)
 RETURNS TABLE(no integer, rxhead_id bigint, tfn bigint, pid text, patient_name text, patient_birth text, patient_memo text, is_complete smallint)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_tenant_id   uuid   := auth.uid();
  v_patient_num bigint := NULL;

  v_local_start timestamp;
  v_start_utc   timestamptz;
  v_end_utc     timestamptz;
BEGIN
  IF _patient_number IS NOT NULL AND trim(_patient_number) <> '' THEN
    v_patient_num := (_patient_number)::bigint;
  END IF;

  IF _selected_date IS NOT NULL AND trim(_selected_date) <> '' THEN
    v_local_start := to_date(_selected_date, 'YYYY-MM-DD')::timestamp;
    v_start_utc   := v_local_start AT TIME ZONE 'Asia/Seoul';
    v_end_utc     := (v_local_start + INTERVAL '1 day') AT TIME ZONE 'Asia/Seoul';
  END IF;

  RETURN QUERY
  SELECT
    rh.proccessing_number                      AS no,
    rh.rxhead_id,
    rh.textfile_number                         AS tfn,
    p.patient_id::text                         AS pid,
    p.patient_name,
    to_char(p.patient_birth, 'YYYY-MM-DD')     AS patient_birth,
    p.patient_memo,
    rh.is_complete
  FROM public.rxheads AS rh
  JOIN public.patients AS p
    ON p.patient_id = rh.patient_id
   AND p.tenant_id  = rh.tenant_id
  WHERE rh.tenant_id = v_tenant_id
    AND (
      v_start_utc IS NULL
      OR (rh.created_at >= v_start_utc AND rh.created_at < v_end_utc)
    )
    AND (v_patient_num IS NULL OR p.patient_number = v_patient_num)
    AND (_patient_name IS NULL OR p.patient_name ILIKE '%' || _patient_name || '%')
  ORDER BY rh.created_at DESC NULLS LAST, rh.rxhead_id DESC
  LIMIT COALESCE(_limit, 50)
 OFFSET COALESCE(_offset, 0);
END;
$function$
"
public,get_rxrecipe_by_textfile_number,_textfile_number bigint,plpgsql,true,v,"CREATE OR REPLACE FUNCTION public.get_rxrecipe_by_textfile_number(_textfile_number bigint)
 RETURNS TABLE(checked smallint, total double precision, drug_name text, dose real, times smallint, days smallint, pack_barcode text, base_barcode text, location text, rxrecipe_id bigint, recipe_order smallint, drug_type text, drug_id uuid, drug_usage text, created_at timestamp with time zone, is_atc boolean, is_use boolean, patientdrug_id bigint, morning real, afternoon real, evening real, night real, special real, usage_code smallint, separate smallint, patientdrugmemo text, patientdrug_created_at timestamp with time zone, patientdrug_updated_at timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_tenant_id uuid := auth.uid();
BEGIN
  RETURN QUERY
  WITH rx AS (
    SELECT
        r.rxrecipe_id,
        r.tenant_id,
        r.drug_id,
        r.recipe_order,
        r.dose,
        r.times,
        r.days,
        r.drug_usage,
        r.textfile_number,
        r.created_at,
        r.checked,
        rh.patient_id,

        -- ========= 패턴 계산 =========
        CASE WHEN r.times >= 1 THEN r.dose ELSE 0 END AS m_morning,
        CASE
          WHEN r.times = 3 THEN r.dose
          WHEN r.times >= 4 THEN r.dose
          ELSE 0
        END AS m_afternoon,
        CASE WHEN r.times >= 2 THEN r.dose ELSE 0 END AS m_evening,
        CASE WHEN r.times = 4 THEN r.dose ELSE 0 END AS m_night,
        0::real AS m_special      -- pattern5용 special 슬롯

    FROM public.rxrecipes r
    JOIN public.rxheads rh
      ON rh.textfile_number = r.textfile_number
     AND rh.tenant_id       = r.tenant_id
    WHERE r.tenant_id       = v_tenant_id
      AND r.textfile_number = _textfile_number
  )
  SELECT
      rx.checked,
      (rx.dose * rx.times * rx.days) AS total,
      d.drug_name,
      rx.dose,
      rx.times,
      rx.days,
      d.pack_barcode,
      d.base_barcode,
      d.location,
      rx.rxrecipe_id,
      rx.recipe_order,
      d.drug_type,
      rx.drug_id,
      rx.drug_usage,
      rx.created_at,
      d.is_atc,
      d.is_pharmacy_use AS is_use,   -- ✅ 변경 포인트

      pd.patientdrug_id,
      pd.morning,
      pd.afternoon,
      pd.evening,
      pd.night,
      pd.special,
      pd.usage_code,
      pd.separate,
      pd.patientdrugmemo,
      pd.created_at AS patientdrug_created_at,
      pd.updated_at AS patientdrug_updated_at

  FROM rx
  LEFT JOIN public.drugs d
         ON d.id        = rx.drug_id
        AND d.tenant_id = rx.tenant_id

  -- ========= patient_drugs 매칭 =========
  LEFT JOIN public.patient_drugs pd
         ON pd.tenant_id  = rx.tenant_id
        AND pd.patient_id = rx.patient_id
        AND pd.drug_id    = rx.drug_id
        AND pd.is_patient_use = true          -- ✅ 의미상 안전한 필터 (권장)

        -- 1) 패턴 구조 동일 (sorted_pattern5)
        AND public.sorted_pattern5(
              pd.morning,
              pd.afternoon,
              pd.evening,
              pd.night,
              pd.special
            ) =
            public.sorted_pattern5(
              rx.m_morning,
              rx.m_afternoon,
              rx.m_evening,
              rx.m_night,
              rx.m_special
            )

        -- 2) dose 값一致 (기존 안전 조건 유지)
        AND (
              pd.morning   = rx.dose
           OR pd.afternoon = rx.dose
           OR pd.evening   = rx.dose
           OR pd.night     = rx.dose
        )

  ORDER BY rx.recipe_order NULLS LAST, rx.rxrecipe_id;
END;
$function$
"
public,get_rxrecipe_details_by_rxrecipe_id,_rxrecipe_id bigint,plpgsql,true,v,"CREATE OR REPLACE FUNCTION public.get_rxrecipe_details_by_rxrecipe_id(_rxrecipe_id bigint)
 RETURNS TABLE(id bigint, rxrecipe_id bigint, pack_serial text, check_consume numeric, updated_at timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  RETURN QUERY
  SELECT
    d.id,
    d.rxrecipe_id,
    d.pack_serial,
    d.check_consume,
    d.updated_at
  FROM public.rxrecipe_details d
  WHERE d.rxrecipe_id = _rxrecipe_id
    AND d.is_alive = true
    AND d.tenant_id = auth.uid();
END;
$function$
"
public,get_unit_from_pack_barcode,_pack_barcode text,plpgsql,false,v,"CREATE OR REPLACE FUNCTION public.get_unit_from_pack_barcode(_pack_barcode text)
 RETURNS real
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_unit      real;
  v_tenant_id uuid := auth.uid();
BEGIN
  --------------------------------------------------------------------
  -- 1) 내 약국(drugs) 우선 조회
  --------------------------------------------------------------------
  SELECT p.unit
    INTO v_unit
  FROM public.drugs p
  WHERE p.tenant_id = v_tenant_id
    AND p.pack_barcode = _pack_barcode
  ORDER BY p.created_at DESC
  LIMIT 1;

  -- unit이 NULL이 아니고, 0보다 큰 ""유효값""이면 반환
  IF v_unit IS NOT NULL AND v_unit > 0 THEN
    RETURN v_unit;
  END IF;

  --------------------------------------------------------------------
  -- 2) 공용 라이브러리 조회
  --------------------------------------------------------------------
  SELECT dl.unit
    INTO v_unit
  FROM public.drug_library dl
  WHERE dl.pack_barcode = _pack_barcode
  ORDER BY dl.id DESC
  LIMIT 1;

  IF v_unit IS NOT NULL AND v_unit > 0 THEN
    RETURN v_unit;
  END IF;

  --------------------------------------------------------------------
  -- 3) 완전히 없는 경우 → NULL 반환
  --------------------------------------------------------------------
  RETURN NULL;
END;
$function$
"
public,increase_checked,"_rxrecipe_id bigint, _delta integer",plpgsql,false,v,"CREATE OR REPLACE FUNCTION public.increase_checked(_rxrecipe_id bigint, _delta integer)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_tenant_id uuid := auth.uid();
BEGIN
  UPDATE public.rxrecipes
     SET checked = GREATEST(0, checked + _delta)
   WHERE rxrecipe_id = _rxrecipe_id
     AND tenant_id = v_tenant_id;
  RETURN FOUND::int;
END;
$function$
"
public,increment_referral_code_usage,p_referral_code_id uuid,plpgsql,true,v,"CREATE OR REPLACE FUNCTION public.increment_referral_code_usage(p_referral_code_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_updated integer;
BEGIN
  UPDATE public.referral_codes
  SET used_count = used_count + 1
  WHERE referral_code_id = p_referral_code_id
    AND is_active = true
    AND (max_uses IS NULL OR used_count < max_uses)
    AND (expires_at IS NULL OR expires_at > now())
  RETURNING 1 INTO v_updated;

  RETURN v_updated IS NOT NULL;
END;
$function$
"
public,insert_full_rx,"_textfile_number bigint, _patient_number bigint, _proccessing_number integer, _prescribe_date date, _patient_birth date, _patient_name text, _hospital_name text, _doctor_name text, _created_at timestamp with time zone, _rxrecipes jsonb",plpgsql,false,v,"CREATE OR REPLACE FUNCTION public.insert_full_rx(_textfile_number bigint, _patient_number bigint, _proccessing_number integer, _prescribe_date date, _patient_birth date, _patient_name text, _hospital_name text, _doctor_name text, _created_at timestamp with time zone, _rxrecipes jsonb)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public'
AS $function$
DECLARE
  v_tenant_id uuid := auth.uid();

  _patient_id uuid;
  _doctor_id  int;

  rec                  jsonb;
  v_drug_type           text;
  v_drug_code           text;
  v_drug_search_code    text;
  v_drug_name           text;
  v_recipe_order        int;
  v_dose                real;
  v_times               int;
  v_days                int;
  v_drug_usage          text;

  v_drug_id             uuid;
  v_temp_drug_id        uuid;
  v_base_barcode        text;

  d_morning             real;
  d_afternoon           real;
  d_evening             real;
  d_night               real;
  d_special             real;

  _pd_id                bigint;
BEGIN
  -------------------------------------------------------------------
  -- 1. Patient UPSERT
  -------------------------------------------------------------------
  INSERT INTO public.patients (
    tenant_id, patient_number, patient_name, patient_birth
  )
  VALUES (
    v_tenant_id, _patient_number, _patient_name, _patient_birth
  )
  ON CONFLICT (tenant_id, patient_number) DO UPDATE
     SET patient_name  = EXCLUDED.patient_name,
         patient_birth = EXCLUDED.patient_birth,
         updated_at    = now()
  RETURNING patient_id INTO _patient_id;

  -------------------------------------------------------------------
  -- 2. Doctor UPSERT
  -------------------------------------------------------------------
  INSERT INTO public.doctors (
    tenant_id, doctor_name, hospital_name
  )
  VALUES (
    v_tenant_id, _doctor_name, _hospital_name
  )
  ON CONFLICT (tenant_id, doctor_name, hospital_name) DO UPDATE
     SET hospital_name = EXCLUDED.hospital_name
  RETURNING doctor_id INTO _doctor_id;

  -------------------------------------------------------------------
  -- 3. RxHead UPSERT
  -------------------------------------------------------------------
  INSERT INTO public.rxheads (
    tenant_id, doctor_id, patient_id,
    textfile_number, proccessing_number,
    prescribe_date, created_at
  )
  VALUES (
    v_tenant_id, _doctor_id, _patient_id,
    _textfile_number, _proccessing_number,
    _prescribe_date, _created_at
  )
  ON CONFLICT (tenant_id, textfile_number) DO UPDATE
     SET doctor_id          = EXCLUDED.doctor_id,
         patient_id         = EXCLUDED.patient_id,
         proccessing_number = EXCLUDED.proccessing_number,
         prescribe_date     = EXCLUDED.prescribe_date,
         created_at         = EXCLUDED.created_at;

  -------------------------------------------------------------------
  -- 4. 기존 RxRecipe 삭제
  -------------------------------------------------------------------
  DELETE FROM public.rxrecipes
   WHERE tenant_id = v_tenant_id
     AND textfile_number = _textfile_number;

  -------------------------------------------------------------------
  -- 5. RxRecipe Loop
  -------------------------------------------------------------------
  FOR rec IN
    SELECT jsonb_array_elements(_rxrecipes)
  LOOP
    v_drug_type        := COALESCE(NULLIF(trim(rec->>'DrugType'), ''), '기타');
    v_drug_code        := rec->>'DrugCode';
    v_drug_name        := rec->>'DrugName';
    v_recipe_order     := (rec->>'RecipeOrder')::int;
    v_dose             := (rec->>'Dose')::real;
    v_times            := COALESCE((rec->>'Times')::int, 1);
    v_days             := NULLIF(rec->>'Days','')::int;
    v_drug_usage       := rec->>'DrugUsage';

    v_drug_id          := NULL;
    v_temp_drug_id     := NULL;
    v_base_barcode     := NULL;
    v_drug_search_code := '880' || v_drug_code || '%';

    -----------------------------------------------------------------
    -- 5-1. 정식 drug UPDATE + RETURNING (drug_type 동기화)
    -----------------------------------------------------------------
    UPDATE public.drugs
       SET drug_type  = v_drug_type,
           updated_at = now()
     WHERE tenant_id = v_tenant_id
       AND base_barcode LIKE v_drug_search_code
       AND COALESCE(unit, 0) = 0
       AND is_temp_barcode = false
     RETURNING id INTO v_drug_id;

    -----------------------------------------------------------------
    -- 5-2. 없으면 temp drug 검색
    -----------------------------------------------------------------
    IF v_drug_id IS NULL THEN
      SELECT id, base_barcode
        INTO v_temp_drug_id, v_base_barcode
        FROM public.drugs
       WHERE tenant_id = v_tenant_id
         AND base_barcode LIKE v_drug_search_code
         AND is_temp_barcode = true
       LIMIT 1;
    END IF;

    -----------------------------------------------------------------
    -- 5-3. temp → drug_library 기준 승격 (unit = 0)
    -----------------------------------------------------------------
    IF v_drug_id IS NULL AND v_temp_drug_id IS NOT NULL THEN
      UPDATE public.drugs d
         SET drug_name       = dl.drug_name,
             unit            = COALESCE(dl.unit, d.unit),
             base_barcode    = dl.base_barcode,
             pack_barcode    = dl.pack_barcode,
             drug_type       = v_drug_type,
             is_temp_barcode = false,
             updated_at      = now()
        FROM public.drug_library dl
       WHERE d.id = v_temp_drug_id
         AND dl.base_barcode LIKE v_drug_search_code
         AND COALESCE(dl.unit, 0) = 0
       RETURNING d.id INTO v_drug_id;
    END IF;

    -----------------------------------------------------------------
    -- 5-4. 승격 실패 시 기존 temp 사용
    -----------------------------------------------------------------
    IF v_drug_id IS NULL THEN
      v_drug_id := v_temp_drug_id;
    END IF;

    -----------------------------------------------------------------
    -- 5-5. temp조차 없으면 새 temp 생성
    -----------------------------------------------------------------
    IF v_drug_id IS NULL THEN
      v_base_barcode := '880' || v_drug_code || '0';

      INSERT INTO public.drugs (
        tenant_id, drug_name, unit, drug_type,
        base_barcode, pack_barcode,
        created_at, is_temp_barcode
      )
      VALUES (
        v_tenant_id,
        v_drug_name,
        0,
        v_drug_type,
        v_base_barcode,
        v_base_barcode,
        now(),
        true
      )
      RETURNING id INTO v_drug_id;
    END IF;

    -----------------------------------------------------------------
    -- 5-6. RxRecipe INSERT
    -----------------------------------------------------------------
    INSERT INTO public.rxrecipes (
      tenant_id, textfile_number, drug_id, recipe_order,
      dose, times, days, drug_usage, created_at
    )
    VALUES (
      v_tenant_id, _textfile_number, v_drug_id, v_recipe_order,
      v_dose, v_times, v_days, v_drug_usage, _created_at
    );

    -----------------------------------------------------------------
    -- 5-7. patient_drugs (기존 로직 그대로)
    -----------------------------------------------------------------
    IF UPPER(v_drug_type) = 'T' THEN
      d_morning := 0; d_afternoon := 0;
      d_evening := 0; d_night := 0; d_special := 0;

      IF v_times <= 1 THEN
        d_morning := v_dose;
      ELSIF v_times = 2 THEN
        d_morning := v_dose; d_evening := v_dose;
      ELSIF v_times = 3 THEN
        d_morning := v_dose; d_afternoon := v_dose; d_evening := v_dose;
      ELSE
        d_morning := v_dose; d_afternoon := v_dose;
        d_evening := v_dose; d_night := v_dose;
      END IF;

      SELECT patientdrug_id
        INTO _pd_id
        FROM public.patient_drugs
       WHERE tenant_id  = v_tenant_id
         AND patient_id = _patient_id
         AND drug_id    = v_drug_id
         AND public.sorted_pattern5(
               morning, afternoon, evening, night, special
             )
           =
             public.sorted_pattern5(
               d_morning, d_afternoon, d_evening, d_night, d_special
             )
       LIMIT 1;

      IF _pd_id IS NOT NULL THEN
        UPDATE public.patient_drugs
           SET created_at = _created_at
         WHERE tenant_id = v_tenant_id
           AND patientdrug_id = _pd_id;
      ELSE
        INSERT INTO public.patient_drugs (
          tenant_id, patient_id, drug_id,
          morning, afternoon, evening, night, special,
          created_at
        )
        VALUES (
          v_tenant_id, _patient_id, v_drug_id,
          d_morning, d_afternoon, d_evening, d_night, d_special,
          _created_at
        );
      END IF;
    END IF;
  END LOOP;
END;
$function$
"
public,insert_pack_barcode_unit,"_pack_barcode text, _drug_name text, _unit real",plpgsql,true,v,"CREATE OR REPLACE FUNCTION public.insert_pack_barcode_unit(_pack_barcode text, _drug_name text, _unit real)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_tenant_id uuid := auth.uid();
  v_drug_id   uuid;
BEGIN
  -- 1️⃣ 기존 약 존재 여부 확인
  SELECT id
    INTO v_drug_id
  FROM public.drugs
  WHERE tenant_id = v_tenant_id
    AND pack_barcode = _pack_barcode
  LIMIT 1;

  -- 2️⃣ 없으면 INSERT
  IF v_drug_id IS NULL THEN
    INSERT INTO public.drugs (
      tenant_id,
      drug_name,
      pack_barcode,
      base_barcode,
      unit,
      is_temp_barcode,
      is_pharmacy_use,
      created_at
    )
    VALUES (
      v_tenant_id,
      COALESCE(NULLIF(trim(_drug_name), ''), 'TEMP-' || _pack_barcode),
      _pack_barcode,
      _pack_barcode,
      _unit,
      true,
      true,
      now()
    )
    RETURNING id INTO v_drug_id;

    RETURN jsonb_build_object(
      'action', 'insert',
      'drug_id', v_drug_id,
      'pack_barcode', _pack_barcode,
      'drug_name', _drug_name,
      'unit', _unit
    );
  END IF;

  -- 3️⃣ 이미 존재하면
  UPDATE public.drugs
     SET unit = CASE
                  WHEN COALESCE(unit, 0) = 0 THEN _unit
                  ELSE unit
                END,
         drug_name = CASE
                       WHEN drug_name IS NULL
                            OR trim(drug_name) = ''
                            OR drug_name LIKE 'TEMP-%'
                       THEN COALESCE(NULLIF(trim(_drug_name), ''), drug_name)
                       ELSE drug_name
                     END,
         updated_at = now()
   WHERE id = v_drug_id
     AND tenant_id = v_tenant_id;

  RETURN jsonb_build_object(
    'action', 'update',
    'drug_id', v_drug_id,
    'pack_barcode', _pack_barcode,
    'drug_name', _drug_name,
    'unit', _unit
  );

END;
$function$
"
public,is_active_user,,sql,true,s,"CREATE OR REPLACE FUNCTION public.is_active_user()
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  select exists (
    select 1
    from users
    where user_id = auth.uid()
      and is_deleted = false
  );
$function$
"
public,request_user_deletion,"_reason text, _ip_address inet, _user_agent text",plpgsql,true,v,"CREATE OR REPLACE FUNCTION public.request_user_deletion(_reason text DEFAULT NULL::text, _ip_address inet DEFAULT NULL::inet, _user_agent text DEFAULT NULL::text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_user_id uuid := auth.uid();
begin
  -- 이미 탈퇴한 경우 방지
  if exists (
    select 1
    from users
    where user_id = v_user_id
      and is_deleted = true
  ) then
    raise exception 'User already deleted';
  end if;

  -- users 업데이트
  update users
     set is_deleted     = true,
         deleted_at     = now(),
         deleted_reason = _reason,
         deleted_by     = null
   where user_id = v_user_id;

  -- 탈퇴 로그 기록
  insert into user_deletion_logs (
    user_id,
    deleted_by,
    reason,
    ip_address,
    user_agent
  ) values (
    v_user_id,
    null,
    _reason,
    _ip_address,
    _user_agent
  );
end;
$function$
"
public,save_patient_drug_modal,"_patientdrug_id bigint, _patient_id uuid, _pack_barcode text, _drug_name text, _morning real, _afternoon real, _evening real, _night real, _special real, _usage_code smallint, _separate smallint, _is_pharmacy_use boolean, _is_patient_use boolean, _patientdrugmemo text, _is_atc boolean, _location text",plpgsql,true,v,"CREATE OR REPLACE FUNCTION public.save_patient_drug_modal(_patientdrug_id bigint, _patient_id uuid, _pack_barcode text, _drug_name text, _morning real, _afternoon real, _evening real, _night real, _special real, _usage_code smallint, _separate smallint, _is_pharmacy_use boolean, _is_patient_use boolean, _patientdrugmemo text, _is_atc boolean, _location text)
 RETURNS TABLE(patientdrug_id bigint, status text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_tenant_id uuid := auth.uid();
  v_drug_id   uuid;
  v_pd_id     bigint;
  v_status    text;
  v_rows      integer;
BEGIN
  IF _pack_barcode IS NULL OR btrim(_pack_barcode) = '' THEN
    RAISE EXCEPTION 'pack_barcode required';
  END IF;

  -- normalize 0 -> NULL to force insert
  IF _patientdrug_id = 0 THEN
    _patientdrug_id := NULL;
  END IF;

  -- 1) find/create drug
  SELECT d.id
    INTO v_drug_id
  FROM public.drugs d
  WHERE d.tenant_id = v_tenant_id
    AND d.pack_barcode = _pack_barcode
  ORDER BY d.created_at DESC NULLS LAST, d.id DESC
  LIMIT 1;

  IF v_drug_id IS NULL THEN
    INSERT INTO public.drugs(
      tenant_id, id, drug_name, pack_barcode, base_barcode, unit, created_at, is_atc, is_pharmacy_use, location
    )
    VALUES (
      v_tenant_id, gen_random_uuid(),
      COALESCE(_drug_name, _pack_barcode),
      _pack_barcode,
      _pack_barcode,
      0, now(),
      COALESCE(_is_atc,false),
      COALESCE(_is_pharmacy_use,true),
      NULLIF(btrim(_location),'')
    )
    RETURNING public.drugs.id INTO v_drug_id;
    v_status := 'drug_created';
  END IF;

    -- 2) persist drug metadata (incl. location) even when patient_drug only is being updated
    UPDATE public.drugs d
      SET drug_name       = COALESCE(_drug_name, d.drug_name),
        is_atc          = COALESCE(_is_atc, d.is_atc),
        is_pharmacy_use = COALESCE(_is_pharmacy_use, d.is_pharmacy_use),
        location        = COALESCE(NULLIF(btrim(_location), ''), d.location),
        updated_at      = now()
    WHERE d.id = v_drug_id
      AND d.tenant_id = v_tenant_id;

  -- 3) upsert patient_drugs (patient use flag stored per patient)
  IF _patientdrug_id IS NOT NULL THEN
    UPDATE public.patient_drugs p
       SET 
           morning         = COALESCE(_morning,0),
           afternoon       = COALESCE(_afternoon,0),
           evening         = COALESCE(_evening,0),
           night           = COALESCE(_night,0),
           special         = COALESCE(_special,0),
           usage_code      = COALESCE(_usage_code, p.usage_code),
           separate        = COALESCE(_separate, p.separate),
          is_patient_use  = COALESCE(_is_patient_use, p.is_patient_use),
           patientdrugmemo = _patientdrugmemo,
           updated_at      = now()
     WHERE p.patientdrug_id = _patientdrug_id
       AND p.tenant_id = v_tenant_id;

    GET DIAGNOSTICS v_rows = ROW_COUNT;
    IF v_rows = 0 THEN
      INSERT INTO public.patient_drugs(
        tenant_id, patient_id, drug_id,
        morning, afternoon, evening, night, special,
        usage_code, separate, is_patient_use, patientdrugmemo, created_at
      )
      VALUES(
        v_tenant_id, _patient_id, v_drug_id,
        COALESCE(_morning,0), COALESCE(_afternoon,0), COALESCE(_evening,0), COALESCE(_night,0), COALESCE(_special,0),
        COALESCE(_usage_code,1), COALESCE(_separate,1), COALESCE(_is_patient_use, COALESCE(_is_pharmacy_use, true)), _patientdrugmemo, now()
      )
      RETURNING public.patient_drugs.patientdrug_id INTO v_pd_id;
      v_status := 'patientdrug_created_fallback';
    ELSE
      v_pd_id := _patientdrug_id;
      v_status := 'patientdrug_updated';
    END IF;
  ELSE
    BEGIN
      INSERT INTO public.patient_drugs(
        tenant_id, patient_id, drug_id,
        morning, afternoon, evening, night, special,
        usage_code, separate, is_patient_use, patientdrugmemo, created_at
      )
      VALUES(
        v_tenant_id, _patient_id, v_drug_id,
        COALESCE(_morning,0), COALESCE(_afternoon,0), COALESCE(_evening,0), COALESCE(_night,0), COALESCE(_special,0),
        COALESCE(_usage_code,1), COALESCE(_separate,1), COALESCE(_is_patient_use, COALESCE(_is_pharmacy_use, true)), _patientdrugmemo, now()
      )
      RETURNING public.patient_drugs.patientdrug_id INTO v_pd_id;
      v_status := 'patientdrug_created';
    EXCEPTION WHEN unique_violation THEN
      SELECT p.patientdrug_id
        INTO v_pd_id
      FROM public.patient_drugs p
      WHERE p.tenant_id   = v_tenant_id
        AND p.patient_id  = _patient_id
        AND p.drug_id     = v_drug_id
        AND public.sorted_pattern4(p.morning, p.afternoon, p.evening, p.night)
            = public.sorted_pattern4(COALESCE(_morning,0), COALESCE(_afternoon,0), COALESCE(_evening,0), COALESCE(_night,0))
      ORDER BY p.created_at DESC NULLS LAST, p.patientdrug_id DESC
      LIMIT 1;

      IF v_pd_id IS NOT NULL THEN
        UPDATE public.patient_drugs p
           SET updated_at = now(),
             is_patient_use = COALESCE(_is_patient_use, p.is_patient_use),
             patientdrugmemo = _patientdrugmemo
         WHERE p.patientdrug_id = v_pd_id
           AND p.tenant_id = v_tenant_id;
        v_status := 'patientdrug_pattern_merged';
      ELSE
        v_status := 'error_pattern_not_found';
      END IF;
    END;
  END IF;

  RETURN QUERY SELECT v_pd_id, v_status;
END;
$function$
"
public,save_patient_drug_modal,"_patientdrug_id bigint, _patient_id uuid, _pack_barcode text, _drug_name text, _morning real, _afternoon real, _evening real, _night real, _special real, _usage_code smallint, _separate smallint, _is_pharmacy_use boolean, _is_patient_use boolean, _u_canister real, _patientdrugmemo text, _is_atc boolean, _location text",plpgsql,true,v,"CREATE OR REPLACE FUNCTION public.save_patient_drug_modal(_patientdrug_id bigint, _patient_id uuid, _pack_barcode text, _drug_name text, _morning real, _afternoon real, _evening real, _night real, _special real, _usage_code smallint, _separate smallint, _is_pharmacy_use boolean, _is_patient_use boolean, _u_canister real, _patientdrugmemo text, _is_atc boolean, _location text)
 RETURNS TABLE(patientdrug_id bigint, status text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_tenant_id uuid := auth.uid();
  v_drug_id   uuid;
  v_pd_id     bigint;
  v_status    text;
  v_rows      integer;
BEGIN
  IF _pack_barcode IS NULL OR btrim(_pack_barcode) = '' THEN
    RAISE EXCEPTION 'pack_barcode required';
  END IF;

  -- normalize 0 -> NULL to force insert
  IF _patientdrug_id = 0 THEN
    _patientdrug_id := NULL;
  END IF;

  -- 1) find/create drug
  SELECT d.id
    INTO v_drug_id
  FROM public.drugs d
  WHERE d.tenant_id = v_tenant_id
    AND d.pack_barcode = _pack_barcode
  ORDER BY d.created_at DESC NULLS LAST, d.id DESC
  LIMIT 1;

  IF v_drug_id IS NULL THEN
    INSERT INTO public.drugs(
      tenant_id, id, drug_name, pack_barcode, base_barcode, unit, created_at, is_atc, is_pharmacy_use, u_canister, location
    )
    VALUES (
      v_tenant_id, gen_random_uuid(),
      COALESCE(_drug_name, _pack_barcode),
      _pack_barcode,
      _pack_barcode,
      0, now(),
      COALESCE(_is_atc,false),
      COALESCE(_is_pharmacy_use,true),
      NULLIF(_u_canister, 0),
      NULLIF(btrim(_location),'')
    )
    RETURNING public.drugs.id INTO v_drug_id;
    v_status := 'drug_created';
  END IF;

    -- 2) persist drug metadata (incl. location) even when patient_drug only is being updated
    UPDATE public.drugs d
      SET drug_name       = COALESCE(_drug_name, d.drug_name),
        is_atc          = COALESCE(_is_atc, d.is_atc),
        is_pharmacy_use = COALESCE(_is_pharmacy_use, d.is_pharmacy_use),
          u_canister      = COALESCE(NULLIF(_u_canister, 0), d.u_canister),
        location        = COALESCE(NULLIF(btrim(_location), ''), d.location),
        updated_at      = now()
    WHERE d.id = v_drug_id
      AND d.tenant_id = v_tenant_id;

  -- 3) upsert patient_drugs (patient use flag stored per patient)
  IF _patientdrug_id IS NOT NULL THEN
    UPDATE public.patient_drugs p
       SET dose            = 0,
           morning         = COALESCE(_morning,0),
           afternoon       = COALESCE(_afternoon,0),
           evening         = COALESCE(_evening,0),
           night           = COALESCE(_night,0),
           special         = COALESCE(_special,0),
           usage_code      = COALESCE(_usage_code, p.usage_code),
           separate        = COALESCE(_separate, p.separate),
          is_patient_use  = COALESCE(_is_patient_use, p.is_patient_use),
           patientdrugmemo = _patientdrugmemo,
           updated_at      = now()
     WHERE p.patientdrug_id = _patientdrug_id
       AND p.tenant_id = v_tenant_id;

    GET DIAGNOSTICS v_rows = ROW_COUNT;
    IF v_rows = 0 THEN
      INSERT INTO public.patient_drugs(
        tenant_id, patient_id, drug_id,
        morning, afternoon, evening, night, special,
        usage_code, separate, is_patient_use, patientdrugmemo, created_at
      )
      VALUES(
        v_tenant_id, _patient_id, v_drug_id,
        COALESCE(_morning,0), COALESCE(_afternoon,0), COALESCE(_evening,0), COALESCE(_night,0), COALESCE(_special,0),
        COALESCE(_usage_code,1), COALESCE(_separate,1), COALESCE(_is_patient_use, COALESCE(_is_pharmacy_use, true)), _patientdrugmemo, now()
      )
      RETURNING public.patient_drugs.patientdrug_id INTO v_pd_id;
      v_status := 'patientdrug_created_fallback';
    ELSE
      v_pd_id := _patientdrug_id;
      v_status := 'patientdrug_updated';
    END IF;
  ELSE
    BEGIN
      INSERT INTO public.patient_drugs(
        tenant_id, patient_id, drug_id,
        morning, afternoon, evening, night, special,
        usage_code, separate, is_patient_use, patientdrugmemo, created_at
      )
      VALUES(
        v_tenant_id, _patient_id, v_drug_id,
        COALESCE(_morning,0), COALESCE(_afternoon,0), COALESCE(_evening,0), COALESCE(_night,0), COALESCE(_special,0),
        COALESCE(_usage_code,1), COALESCE(_separate,1), COALESCE(_is_patient_use, COALESCE(_is_pharmacy_use, true)), _patientdrugmemo, now()
      )
      RETURNING public.patient_drugs.patientdrug_id INTO v_pd_id;
      v_status := 'patientdrug_created';
    EXCEPTION WHEN unique_violation THEN
      SELECT p.patientdrug_id
        INTO v_pd_id
      FROM public.patient_drugs p
      WHERE p.tenant_id   = v_tenant_id
        AND p.patient_id  = _patient_id
        AND p.drug_id     = v_drug_id
        AND public.sorted_pattern4(p.morning, p.afternoon, p.evening, p.night)
            = public.sorted_pattern4(COALESCE(_morning,0), COALESCE(_afternoon,0), COALESCE(_evening,0), COALESCE(_night,0))
      ORDER BY p.created_at DESC NULLS LAST, p.patientdrug_id DESC
      LIMIT 1;

      IF v_pd_id IS NOT NULL THEN
        UPDATE public.patient_drugs p
           SET updated_at = now(),
             is_patient_use = COALESCE(_is_patient_use, p.is_patient_use),
             patientdrugmemo = _patientdrugmemo
         WHERE p.patientdrug_id = v_pd_id
           AND p.tenant_id = v_tenant_id;
        v_status := 'patientdrug_pattern_merged';
      ELSE
        v_status := 'error_pattern_not_found';
      END IF;
    END;
  END IF;

  RETURN QUERY SELECT v_pd_id, v_status;
END;
$function$
"
public,set_rxrecipe_details_dead_by_id,"_id bigint, _rxrecipe_id bigint",plpgsql,true,v,"CREATE OR REPLACE FUNCTION public.set_rxrecipe_details_dead_by_id(_id bigint, _rxrecipe_id bigint)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_check_consume numeric;
  v_rows integer := 0;
BEGIN
  /*
    1. 살아있는 row만 dead 처리
    2. 동시에 check_consume 확보
    → 경쟁 조건 완전 제거
  */
  UPDATE public.rxrecipe_details
     SET is_alive   = false,
         updated_at = now()
   WHERE id = _id
     AND rxrecipe_id = _rxrecipe_id
     AND tenant_id = auth.uid()
     AND is_alive = true
   RETURNING check_consume
     INTO v_check_consume;

  GET DIAGNOSTICS v_rows = ROW_COUNT;

  -- 이미 죽어있었거나 없으면 종료
  IF v_rows = 0 THEN
    RETURN 0;
  END IF;

  -- checked 차감 (0 이하 방지)
  UPDATE public.rxrecipes
     SET checked = GREATEST(
                     checked - COALESCE(v_check_consume, 0),
                     0
                   )
   WHERE rxrecipe_id = _rxrecipe_id
     AND tenant_id = auth.uid();

  RETURN 1;
END;
$function$
"
public,sorted_pattern5,"a real, b real, c real, d real, e real",sql,false,i,"CREATE OR REPLACE FUNCTION public.sorted_pattern5(a real, b real, c real, d real, e real)
 RETURNS real[]
 LANGUAGE sql
 IMMUTABLE STRICT
AS $function$
  SELECT ARRAY(
    SELECT v FROM (VALUES (a),(b),(c),(d),(e)) t(v) ORDER BY v
  );
$function$
"
public,trg_rxrecipe_details_after_delete,,plpgsql,true,v,"CREATE OR REPLACE FUNCTION public.trg_rxrecipe_details_after_delete()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_delta int;
BEGIN
  -- check_consume가 NULL이면 0으로 처리
  v_delta := COALESCE(OLD.check_consume, 0)::int;

  -- 감소할 값이 없으면 아무것도 안 함
  IF v_delta = 0 THEN
    RETURN OLD;
  END IF;

  UPDATE public.rxrecipes
     SET checked = GREATEST(0, checked - v_delta)
   WHERE rxrecipe_id = OLD.rxrecipe_id
     AND tenant_id   = OLD.tenant_id;

  RETURN OLD;
END;
$function$
"
public,undo_user_deletion,_user_id uuid,plpgsql,true,v,"CREATE OR REPLACE FUNCTION public.undo_user_deletion(_user_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  UPDATE public.users
     SET is_deleted     = false,
         deleted_at     = NULL,
         deleted_reason = NULL,
         deleted_by     = NULL,
         updated_at     = now()
   WHERE user_id = _user_id
     AND is_deleted = true
     AND deleted_at > now() - interval '7 days';

  IF NOT FOUND THEN
    RAISE EXCEPTION 'cannot undo deletion';
  END IF;
END;
$function$
"
public,update_admin_user_memos_updated_at,,plpgsql,false,v,"CREATE OR REPLACE FUNCTION public.update_admin_user_memos_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$function$
"
public,update_atc_drug,"v_drug_name text, v_drug_code text",plpgsql,true,v,"CREATE OR REPLACE FUNCTION public.update_atc_drug(v_drug_name text, v_drug_code text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_tenant_id        uuid := auth.uid();
  v_drug_search_code text;
  v_drug_id          uuid;
  v_temp_drug_id     uuid;
  v_base_barcode     text;
BEGIN
  -----------------------------------------------------------------
  -- 1. 검색용 바코드 패턴 생성
  -----------------------------------------------------------------
  v_drug_search_code := '880' || v_drug_code || '%';

  -----------------------------------------------------------------
  -- 2. drugs에서 정식 drug 우선 검색 (is_temp_barcode = false)
  -----------------------------------------------------------------
  SELECT id
    INTO v_drug_id
    FROM public.drugs
   WHERE tenant_id = v_tenant_id
     AND base_barcode LIKE v_drug_search_code
     AND COALESCE(unit, 0) = 0
     AND is_temp_barcode = false
   LIMIT 1;

  -----------------------------------------------------------------
  -- 3. 정식 drug 없으면 temp drug 검색
  -----------------------------------------------------------------
  IF v_drug_id IS NULL THEN
    SELECT id, base_barcode
      INTO v_temp_drug_id, v_base_barcode
      FROM public.drugs
     WHERE tenant_id = v_tenant_id
       AND base_barcode LIKE v_drug_search_code
       AND is_temp_barcode = true
     LIMIT 1;
  END IF;

  -----------------------------------------------------------------
  -- 4. temp drug가 있다면 drug_library 기준으로 승격 시도
  -----------------------------------------------------------------
  IF v_drug_id IS NULL AND v_temp_drug_id IS NOT NULL THEN
    UPDATE public.drugs d
       SET drug_name       = dl.drug_name,
           unit            = COALESCE(dl.unit, d.unit),
           base_barcode    = dl.base_barcode,
           pack_barcode    = dl.pack_barcode,
           is_temp_barcode = false,
           is_atc          = true,
           updated_at      = now()
      FROM public.drug_library dl
     WHERE d.id = v_temp_drug_id
       AND dl.base_barcode LIKE v_drug_search_code
       AND COALESCE(dl.unit, 0) = 0
     RETURNING d.id INTO v_drug_id;
  END IF;

  -----------------------------------------------------------------
  -- 5. 승격 실패 시 temp drug 그대로 사용
  -----------------------------------------------------------------
  IF v_drug_id IS NULL THEN
    v_drug_id := v_temp_drug_id;
  END IF;

  -----------------------------------------------------------------
  -- 6. temp drug조차 없으면 새 temp 생성
  -----------------------------------------------------------------
  IF v_drug_id IS NULL THEN
    v_base_barcode := '880' || v_drug_code || '0';

    INSERT INTO public.drugs (
      tenant_id,
      drug_name,
      unit,
      base_barcode,
      pack_barcode,
      is_temp_barcode,
      is_atc,
      created_at
    )
    VALUES (
      v_tenant_id,
      v_drug_name,
      0,
      v_base_barcode,
      v_base_barcode,
      true,
      true,
      now()
    )
    RETURNING id INTO v_drug_id;
  END IF;

  -----------------------------------------------------------------
  -- 7. 최종 보정: 어떤 경로든 ATC 약으로 확정
  -----------------------------------------------------------------
  UPDATE public.drugs
     SET is_atc     = true,
         updated_at = now()
   WHERE id = v_drug_id
     AND tenant_id = v_tenant_id;

  RETURN true;
END;
$function$
"
public,update_checked_and_packserial,"_rxrecipe_id bigint, _delta integer, _pack_serial text",plpgsql,false,v,"CREATE OR REPLACE FUNCTION public.update_checked_and_packserial(_rxrecipe_id bigint, _delta integer, _pack_serial text)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_rows      int := 0;
  v_delta     int := COALESCE(_delta, 0);
  v_tenant_id uuid := auth.uid();
  v_serial    text := NULLIF(TRIM(_pack_serial), '');
BEGIN
  -- 0) pack_serial 미지정: checked 값만 증감
  IF v_serial IS NULL THEN
    UPDATE public.rxrecipes
       SET checked = GREATEST(0, LEAST(32767, checked + v_delta))
     WHERE rxrecipe_id = _rxrecipe_id
       AND tenant_id   = v_tenant_id;


    RETURN jsonb_build_object('delta', v_delta, 'reason', 'no-serial');
  END IF;


  -- 1) 디테일 삽입: is_alive = true 로 삽입
  INSERT INTO public.rxrecipe_details (
      tenant_id, rxrecipe_id, pack_serial,check_consume, is_alive, created_at, updated_at
  )
  VALUES (
      v_tenant_id, _rxrecipe_id, v_serial,v_delta, true, now(), now()
  )
  ON CONFLICT (tenant_id, rxrecipe_id, pack_serial, is_alive) DO NOTHING;


  GET DIAGNOSTICS v_rows = ROW_COUNT;  -- 1=신규삽입, 0=이미 같은 alive row 존재


  IF v_rows = 1 THEN
    -- 2-a) 신규 삽입 성공: rxrecipes.checked 증감
    UPDATE public.rxrecipes
       SET checked = GREATEST(0, LEAST(32767, checked + v_delta))
     WHERE rxrecipe_id = _rxrecipe_id
       AND tenant_id   = v_tenant_id;


    RETURN jsonb_build_object('delta', v_delta, 'reason', 'inserted');
  ELSE
    -- 2-b) 이미 살아있는 동일 시리얼이 있을 때: updated_at만 갱신
    UPDATE public.rxrecipe_details
       SET updated_at = now()
     WHERE tenant_id   = v_tenant_id
       AND rxrecipe_id = _rxrecipe_id
       AND pack_serial = v_serial
       AND is_alive    = true;


    RETURN jsonb_build_object('delta', 0, 'reason', 'duplicate');
  END IF;
END;
$function$
"
public,update_drug_location_by_drug_code,"v_drug_name text, v_drug_code text, _location text",plpgsql,false,v,"CREATE OR REPLACE FUNCTION public.update_drug_location_by_drug_code(v_drug_name text, v_drug_code text, _location text)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_tenant_id        uuid := auth.uid();
  v_drug_search_code text;
  v_drug_id          uuid;
  v_temp_drug_id     uuid;
  v_base_barcode     text;
BEGIN
  -----------------------------------------------------------------
  -- 1. 검색용 바코드 패턴 생성
  -----------------------------------------------------------------
  v_drug_search_code := '880' || v_drug_code || '%';

  -----------------------------------------------------------------
  -- 2. drugs에서 정식 drug 우선 검색 (is_temp_barcode = false)
  -----------------------------------------------------------------
  SELECT id
    INTO v_drug_id
    FROM public.drugs
   WHERE tenant_id = v_tenant_id
     AND base_barcode LIKE v_drug_search_code
     AND COALESCE(unit, 0) = 0
     AND is_temp_barcode = false
   LIMIT 1;

  -----------------------------------------------------------------
  -- 3. 정식 drug 없으면 temp drug 검색
  -----------------------------------------------------------------
  IF v_drug_id IS NULL THEN
    SELECT id, base_barcode
      INTO v_temp_drug_id, v_base_barcode
      FROM public.drugs
     WHERE tenant_id = v_tenant_id
       AND base_barcode LIKE v_drug_search_code
       AND is_temp_barcode = true
     LIMIT 1;
  END IF;

  -----------------------------------------------------------------
  -- 4. temp drug가 있다면 drug_library 기준으로 승격 시도
  --    (base_barcode LIKE + unit = 0 조건)
  -----------------------------------------------------------------
  IF v_drug_id IS NULL AND v_temp_drug_id IS NOT NULL THEN
    UPDATE public.drugs d
       SET drug_name       = dl.drug_name,
           unit            = COALESCE(dl.unit, d.unit),
           base_barcode    = dl.base_barcode,
           pack_barcode    = dl.pack_barcode,
           is_temp_barcode = false,
           updated_at      = now()
      FROM public.drug_library dl
     WHERE d.id = v_temp_drug_id
       AND dl.base_barcode LIKE v_drug_search_code
       AND COALESCE(dl.unit, 0) = 0
     RETURNING d.id INTO v_drug_id;
  END IF;

  -----------------------------------------------------------------
  -- 5. 승격 실패 시 temp drug 그대로 사용
  -----------------------------------------------------------------
  IF v_drug_id IS NULL THEN
    v_drug_id := v_temp_drug_id;
  END IF;

  -----------------------------------------------------------------
  -- 6. temp drug조차 없으면 새 temp 생성
  -----------------------------------------------------------------
  IF v_drug_id IS NULL THEN
    v_base_barcode := '880' || v_drug_code || '0';

    INSERT INTO public.drugs (
      tenant_id,
      drug_name,
      unit,
      base_barcode,
      pack_barcode,
      is_temp_barcode,
      created_at
    )
    VALUES (
      v_tenant_id,
      v_drug_name,
      0,
      v_base_barcode,
      v_base_barcode,
      true,
      now()
    )
    RETURNING id INTO v_drug_id;
  END IF;

  -----------------------------------------------------------------
  -- 7. location 업데이트 (temp / 정식 구분 없이)
  -----------------------------------------------------------------
  UPDATE public.drugs
     SET location   = _location,
         updated_at = now()
   WHERE id = v_drug_id
     AND tenant_id = v_tenant_id;

  RETURN true;
END;
$function$
"
public,update_patient_memo_by_id,"_patient_id uuid, _memo text",plpgsql,false,v,"CREATE OR REPLACE FUNCTION public.update_patient_memo_by_id(_patient_id uuid, _memo text)
 RETURNS patients
 LANGUAGE plpgsql
 SET search_path TO 'public'
AS $function$
DECLARE
  rec public.patients;
BEGIN
  UPDATE public.patients
     SET patient_memo = _memo,
         updated_at   = now()
   WHERE patient_id = _patient_id
     AND tenant_id  = auth.uid()
  RETURNING * INTO rec;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'patient not found or not permitted'
      USING ERRCODE = 'P0002';
  END IF;

  RETURN rec;
END;
$function$
"
public,update_rxhead_completed,"_rxhead_id bigint, _is_completed smallint",plpgsql,true,v,"CREATE OR REPLACE FUNCTION public.update_rxhead_completed(_rxhead_id bigint, _is_completed smallint)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_tenant_id uuid := auth.uid();
BEGIN
  IF _rxhead_id IS NULL THEN
    RAISE EXCEPTION 'rxhead_id required';
  END IF;

  IF _is_completed NOT IN (1,2) THEN
    RAISE EXCEPTION 'is_completed must be 1 or 2';
  END IF;

  UPDATE public.rxheads rh
     SET is_complete = _is_completed,
         completed_at = now()
   WHERE rh.tenant_id = v_tenant_id
     AND rh.rxhead_id = _rxhead_id;
END;
$function$
"
public,update_updated_at_column,,plpgsql,false,v,"CREATE OR REPLACE FUNCTION public.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$function$
"
public,upsert_drug_library_conditional,_rows jsonb,plpgsql,false,v,"CREATE OR REPLACE FUNCTION public.upsert_drug_library_conditional(_rows jsonb)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  INSERT INTO public.drug_library (
    pack_barcode,
    drug_name,
    unit,
    base_barcode,
    approval_date
  )
  SELECT
    trim(r->>'pack_barcode'),
    r->>'drug_name',
    NULLIF(r->>'unit','')::numeric,
    r->>'base_barcode',
    CASE
      WHEN r->>'approval_date' ~ '^\d{4}-\d{2}-\d{2}$'
      THEN (r->>'approval_date')::date
      ELSE NULL
    END
  FROM jsonb_array_elements(_rows) r
  WHERE trim(r->>'pack_barcode') IS NOT NULL
    AND trim(r->>'pack_barcode') <> ''

  ON CONFLICT (pack_barcode)
  DO UPDATE SET
    drug_name     = EXCLUDED.drug_name,
    unit          = EXCLUDED.unit,
    base_barcode  = EXCLUDED.base_barcode,
    approval_date = EXCLUDED.approval_date,
    updated_at    = now()

  WHERE
    drug_library.drug_name      IS DISTINCT FROM EXCLUDED.drug_name
    OR drug_library.unit        IS DISTINCT FROM EXCLUDED.unit
    OR drug_library.base_barcode IS DISTINCT FROM EXCLUDED.base_barcode
    OR drug_library.approval_date IS DISTINCT FROM EXCLUDED.approval_date;
END;
$function$
"